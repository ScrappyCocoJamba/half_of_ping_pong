# подключаем графическую библиотеку
from tkinter import *

# подключаем модули, отвечающие за время и случайные числа
import time
import random

# создаём новый объект - окно с игровым полем. Назовём переменную окна - tk, она создаётся из класса Tk() - он уже есть
# в гафической библиотеке
tk = Tk()

# делаем заголовок окна — Games с помощью свойства объекта title
tk.title('Game')

# запрещаем менять размеры окна, для этого используем свойство resizable
tk.resizable(0, 0)

# помещаем наше игровое окно выше остальных окон на компьютере, чтобы другие окна не могли его заслонить
tk.wm_attributes('-topmost', 1)

# создаём новый холст — 400 на 500 пикселей, где и будем рисовать игру
canvas = Canvas(tk, width=500, height=400, highlightthickness=0)

# говорим холсту, что у каждого видимого элемента будут свои отдельные координаты
canvas.pack()

# обновляем окно с холстом
tk.update()



# Описываем класс Ball, который будет отвечать за шарик
class Ball:

    # конструктор — он вызывается в момент создания нового объекта на основе этого класса
    def __init__(self, canvas, paddle, score, color):

        # задаём параметры объекта, которые нам передают параметры в скобках в момент создания
        self.canvas = canvas
        self.paddle = paddle
        self.score = score

        # цвет нужен был для того, тчобы им закрасить весь шарик
        # тут появляется новое свойство id, в котором хранятится внутреннее название шарика
        # а ещё, командой create_oval мы создаём шарик радиусом 15 пикселей и закрашиваем нужным цветом
        self.id = canvas.create_oval(10, 10, 25, 25, fill=color)

        # помещаем шарик в точку с координатами 245, 100
        self.canvas.move(self.id, 245, 100)

        # задаём список возможных направлений движения для старта
        starts = [-2, -1, 1, 2]

        # перемешиваем его
        random.shuffle(starts)

        # выбираем первый из перемешанного — это будет вектор движения шарика
        self.x = starts[0]

        # в самом начале он всегда падает вниз, поэтому уменьшаем значение по оси y
        self.y = -2

        # шарик узнаёт свою высоту и ширину
        self.canvas_height = self.canvas.winfo_height()
        self.canvas_width = self.canvas.winfo_width()

        # свойство, которое отвечает за то, достиг шарик дна или нет. Пока не достиг, значение будет False
        self.hit_bottom = False

    # обрабатываем касание платформы, для этого получаем 4 координаты шарика
    # в переменной pos (левая верхняя и правая нижняя точки)
    def hit_paddle(self, pos):

        # получаем кординаты платформы через объект paddle (платформа)
        paddle_pos = self.canvas.coords(self.paddle.id)






